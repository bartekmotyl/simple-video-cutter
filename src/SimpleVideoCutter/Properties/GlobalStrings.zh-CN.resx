<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AboutBox_About" xml:space="preserve">
    <value>关于我们</value>
  </data>
  <data name="AboutBox_NewVersionAvailable" xml:space="preserve">
    <value>新版本推出了！请访问项目页面。请访问项目页面。</value>
  </data>
  <data name="AboutBox_Version" xml:space="preserve">
    <value>版本</value>
  </data>
  <data name="AboutBox_VersionUpToDate" xml:space="preserve">
    <value>你正在运行最新的版本。</value>
  </data>
  <data name="FormAddTask_Explanation" xml:space="preserve">
    <value>在这个窗口中，你可以从现有的FFmpeg配置文件中选择（或定义一个新的配置文件），在转换视频时使用。FFmpeg profile是一组参数，用于切割你的视频。如果你对FFmpeg不了解，不要担心--只需按{1}，任务就会自动启动（使用默认的配置文件），这个窗口不会再显示。但是你可以在点击'{0}'的时候按住Shift键将其带回来。

TL;DR：按'{1}'就可以了。窗口不会再显示。</value>
  </data>
  <data name="FormAddTask_OverwwriteProfileQuestion" xml:space="preserve">
    <value>你确定要覆盖配置文件{0}吗？</value>
  </data>
  <data name="FormAddTask_SameAsSource" xml:space="preserve">
    <value>同源</value>
  </data>
  <data name="FormSettings_DefaultDirecttoryTooltip" xml:space="preserve">
    <value>打开视频文件时的默认目录。
可指定为绝对路径
或通过使用预定义的目录之一。
{0}</value>
  </data>
  <data name="FormSettings_ExecutableFiles" xml:space="preserve">
    <value>可执行文件</value>
  </data>
  <data name="FormSettings_OutputDirectoryTooltip" xml:space="preserve">
    <value>输出目录，创建的文件将被保存在其中。
可以指定为绝对路径
或通过使用预定义的目录之一。
{0}</value>
  </data>
  <data name="FormSettings_OutputFileNamePatternTooltip" xml:space="preserve">
    <value>定义了如何计算创建文件的文件名的模式。
静态部分和这些伪变量一样，也允许使用静态部分。
  {0} - 原始文件的文件名
  {1}- 原文件名，不含扩展名
  {2} - 原始视频文件的扩展名
  {3} - 原始视频文件的文件日期
  {4}- 当前时间戳</value>
  </data>
  <data name="GlobalInformation" xml:space="preserve">
    <value>信息</value>
  </data>
  <data name="GlobalQuestion" xml:space="preserve">
    <value>疑问</value>
  </data>
  <data name="MainForm_AllVideoFiles" xml:space="preserve">
    <value>所有视频文件</value>
  </data>
  <data name="MainForm_ButtonCut" xml:space="preserve">
    <value>执行切割</value>
  </data>
  <data name="MainForm_DeaultLayoutrestoredAfterRestart" xml:space="preserve">
    <value>当应用程序重新启动后，将恢复默认布局。</value>
  </data>
  <data name="MainForm_NoSelection" xml:space="preserve">
    <value>没有选择</value>
  </data>
  <data name="MainForm_QuestionRestartNewLanguage" xml:space="preserve">
    <value>为了使用新的语言设置，需要重新启动应用程序。你想现在就重启吗？</value>
  </data>
  <data name="MainForm_Selection" xml:space="preserve">
    <value>挑选</value>
  </data>
  <data name="MainForm_Volume" xml:space="preserve">
    <value>体积</value>
  </data>
  <data name="TaskProcessor_Done" xml:space="preserve">
    <value>已完成</value>
  </data>
  <data name="TaskProcessor_Failure" xml:space="preserve">
    <value>失败</value>
  </data>
  <data name="TaskProcessor_Processed" xml:space="preserve">
    <value>处理{0}秒</value>
  </data>
  <data name="TaskProcessor_State_FinishedError" xml:space="preserve">
    <value>错误</value>
  </data>
  <data name="TaskProcessor_State_FinishedOK" xml:space="preserve">
    <value>已完成</value>
  </data>
  <data name="TaskProcessor_State_InProgress" xml:space="preserve">
    <value>正在进行中</value>
  </data>
  <data name="TaskProcessor_State_Scheduled" xml:space="preserve">
    <value>计划中的</value>
  </data>
  <data name="VideoCutterTimeline_HoveredTime" xml:space="preserve">
    <value>悬停时间</value>
  </data>
  <data name="VideoCutterTimeline_MoveClipEnd" xml:space="preserve">
    <value>挪动夹子</value>
  </data>
  <data name="VideoCutterTimeline_MoveClipStart" xml:space="preserve">
    <value>挪动夹子开始</value>
  </data>
  <data name="VideoCutterTimeline_SetClipStartHere" xml:space="preserve">
    <value>中间点击设置剪辑从这里开始</value>
  </data>
  <data name="VideoCutterTimeline_Time" xml:space="preserve">
    <value>时间</value>
  </data>
  <data name="GlobalCancel" xml:space="preserve">
    <value>取消</value>
  </data>
  <data name="GlobalClose" xml:space="preserve">
    <value>关闭</value>
  </data>
  <data name="VideoCutterTimeline_SetClipFromHereTillEnd" xml:space="preserve">
    <value>按shift+中键，从这一点开始设置剪辑，直到结束。</value>
  </data>
  <data name="VideoCutterTimeline_SetClipFromStartTillHere" xml:space="preserve">
    <value>控件+中间点击，设置从开始到现在的剪辑。</value>
  </data>
  <data name="VideoCutterTimeline_SetClipEndHere" xml:space="preserve">
    <value>中间点击设置剪辑结束这里
提示：也可以用shift/control试试。</value>
  </data>
</root>